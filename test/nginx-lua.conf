worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    upstream foo.com {
        server 127.0.0.1:80;
        server 127.0.0.1:80 backup;
    }

    # GeoIP
    geoip2 /etc/nginx/geoip/GeoLite2-Country.mmdb {
        auto_reload 5m;
        $geoip2_data_country_code source=$http_x_fake_source country iso_code;
        $geoip2_data_country_name source=$http_x_fake_source country names en;
    }
    geoip2 /etc/nginx/geoip/GeoLite2-City.mmdb {
        $geoip2_data_city_name source=$http_x_fake_source city names en;
        $geoip2_data_city_latitude source=$http_x_fake_source location latitude;
        $geoip2_data_city_longitude source=$http_x_fake_source location longitude;
    }
    fastcgi_param COUNTRY_CODE $geoip2_data_country_code;
    fastcgi_param COUNTRY_NAME $geoip2_data_country_name;
    fastcgi_param CITY_NAME    $geoip2_data_city_name;
    fastcgi_param CITY_LAT     $geoip2_data_city_latitude;
    fastcgi_param CITY_LONG    $geoip2_data_city_longitude;

    # REF: https://github.com/openresty/lua-resty-upstream-healthcheck
    lua_shared_dict healthcheck 1m;
    lua_socket_log_errors off;

    # REF: https://github.com/knyar/nginx-lua-prometheus
    lua_shared_dict prometheus_metrics 10M;
    # lua_package_path "/path/to/nginx-lua-prometheus/?.lua;;";
    log_by_lua_block {
        metric_requests:inc(1, {ngx.var.server_name, ngx.var.status})
        metric_latency:observe(tonumber(ngx.var.request_time), {ngx.var.server_name})
    }
    init_worker_by_lua_block {
        prometheus = require("prometheus").init("prometheus_metrics")
        metric_requests = prometheus:counter(
            "nginx_http_requests_total", "Number of HTTP requests", {"host", "status"})
        metric_latency = prometheus:histogram(
            "nginx_http_request_duration_seconds", "HTTP request latency", {"host"})
        metric_connections = prometheus:gauge(
            "nginx_http_connections", "Number of HTTP connections", {"state"})

        local hc = require "resty.upstream.healthcheck"
        local ok, err = hc.spawn_checker{
            shm = "healthcheck",  -- defined by "lua_shared_dict"
            upstream = "foo.com", -- defined by "upstream"
            type = "http", -- support "http" and "https"
            http_req = "GET /status HTTP/1.0\r\nHost: foo.com\r\n\r\n",
                    -- raw HTTP request for checking
            port = nil,  -- the check port, it can be different than the original backend server port, default means the same as the original backend server
            interval = 2000,  -- run the check cycle every 2 sec
            timeout = 1000,   -- 1 sec is the timeout for network operations
            fall = 3,  -- # of successive failures before turning a peer down
            rise = 2,  -- # of successive successes before turning a peer up
            valid_statuses = {200, 302},  -- a list valid HTTP status code
            concurrency = 10,  -- concurrency level for test requests
            -- ssl_verify = true, -- https type only, verify ssl certificate or not, default true
            -- host = foo.com, -- https type only, host name in ssl handshake, default nil
        }
        if not ok then
            ngx.log(ngx.ERR, "failed to spawn health checker: ", err)
            return
        end
    }

    # Optional, but would be required if dropping the 5.1 symlink pointing to 5.4,
    # and it could be possibly a breaking-change.
    # set search paths for pure Lua external libraries (';;' is the default path):
    lua_package_path '/usr/local/share/lua/5.4/?.lua;;';
    # set search paths for Lua external libraries written in C (can also use ';;'):
    lua_package_cpath '/usr/local/lib/lua/5.4/?.so;;';

    # REF: https://github.com/openresty/set-misc-nginx-module
    upstream_list universe moon sun earth;
    upstream moon { server 127.0.0.1; }
    upstream sun { server 127.0.0.1; }
    upstream earth { server 127.0.0.1; }

    server {
        listen       80;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location = /geo/country {
            return 200 $geoip2_data_country_code;
        }

        location = /geo/city {
            return 200 "$geoip2_data_city_name ($geoip2_data_city_latitude, $geoip2_data_city_longitude)";
        }

        location = /lua_content {
            default_type 'text/plain';
            content_by_lua_block {
                ngx.say('Hello world!')
            }
        }

        location = /status {
            access_log off;
            allow 127.0.0.1;
            deny all;
            default_type text/plain;
            content_by_lua_block {
                local hc = require "resty.upstream.healthcheck"
                ngx.say("Nginx Worker PID: ", ngx.worker.pid())
                ngx.print(hc.status_page())
            }
        }
        # status page for all the peers (prometheus format):
        location = /metrics {
            access_log off;
            default_type text/plain;
            content_by_lua_block {
                local hc = require "resty.upstream.healthcheck"
                st , err = hc.prometheus_status_page()
                if not st then
                    ngx.say(err)
                    return
                end
                ngx.print(st)
            }
        }

        # REF: https://github.com/openresty/lua-resty-websocket
        location = /socket {
            content_by_lua_block {
                local server = require "resty.websocket.server"
                local wb, err = server:new{
                    timeout = 5000,
                    max_payload_len = 65535,
                }
                if not wb then
                    ngx.log(ngx.ERR, "failed to new websocket: ", err)
                    return ngx.exit(444)
                end
                local data, typ, err = wb:recv_frame()
                if not data then
                    if not string.find(err, "timeout", 1, true) then
                        ngx.log(ngx.ERR, "failed to receive a frame: ", err)
                        return ngx.exit(444)
                    end
                end
                if typ == "close" then
                    local code = err
                    local bytes, err = wb:send_close(1000, "enough, enough!")
                    if not bytes then
                        ngx.log(ngx.ERR, "failed to send the close frame: ", err)
                        return
                    end
                    ngx.log(ngx.INFO, "closing with status code ", code, " and message ", data)
                    return
                end
                if typ == "ping" then
                    local bytes, err = wb:send_pong(data)
                    if not bytes then
                        ngx.log(ngx.ERR, "failed to send frame: ", err)
                        return
                    end
                elseif typ == "pong" then
                else
                    ngx.log(ngx.INFO, "received a frame of type ", typ, " and payload ", data)
                end
                wb:set_timeout(1000)
                bytes, err = wb:send_text("Hello world")
                if not bytes then
                    ngx.log(ngx.ERR, "failed to send a text frame: ", err)
                    return ngx.exit(444)
                end
                bytes, err = wb:send_binary("blah blah blah...")
                if not bytes then
                    ngx.log(ngx.ERR, "failed to send a binary frame: ", err)
                    return ngx.exit(444)
                end
                local bytes, err = wb:send_close(1000, "enough, enough!")
                if not bytes then
                    ngx.log(ngx.ERR, "failed to send the close frame: ", err)
                    return
                end
            }
        }

        # REF: https://github.com/openresty/lua-resty-shell
        location = /shell {
            content_by_lua_block {
                local shell = require "resty.shell"
                local stdin = "hello"
                local timeout = 1000
                local max_size = 4096
                local ok, stdout, stderr, reason, status =
                shell.run([[sh -c 'echo $0']], stdin, timeout, max_size)
                if not ok then
                    ngx.say('not ok')
                else
                    ngx.say('ok')
                end
            }
        }

        # REF: https://github.com/openresty/lua-resty-dns
        location = /dns {
            content_by_lua_block {
                local resolver = require "resty.dns.resolver"
                local r, err = resolver:new{
                    nameservers = {"8.8.8.8", {"8.8.4.4", 53} },
                    retrans = 5,  -- 5 retransmissions on receive timeout
                    timeout = 2000,  -- 2 sec
                    no_random = true, -- always start with first nameserver
                }
                if not r then
                    ngx.say("failed to instantiate the resolver: ", err)
                    return
                end
                local answers, err, tries = r:query("www.google.com", nil, {})
                if not answers then
                    ngx.say("failed to query the DNS server: ", err)
                    ngx.say("retry historie:\n  ", table.concat(tries, "\n  "))
                    return
                end
                if answers.errcode then
                    ngx.say("server returned error code: ", answers.errcode,
                            ": ", answers.errstr)
                end
                for i, ans in ipairs(answers) do
                    ngx.say(ans.name, " ", ans.address or ans.cname,
                            " type:", ans.type, " class:", ans.class,
                            " ttl:", ans.ttl)
                end
            }
        }

        # REF: https://github.com/cloudflare/lua-resty-cookie
        location = /cookie {
            content_by_lua '
                local ck = require "resty.cookie"
                local cookie, err = ck:new()
                if not cookie then
                    ngx.log(ngx.ERR, err)
                    return
                end
                local field, err = cookie:get("lang")
                if not field then
                    ngx.log(ngx.ERR, err)
                    return
                end
                -- ngx.say("lang", " => ", field)
                local fields, err = cookie:get_all()
                if not fields then
                    ngx.log(ngx.ERR, err)
                    return
                end
                for k, v in pairs(fields) do
                    -- ngx.say(k, " => ", v)
                end
                local ok, err = cookie:set({
                    key = "Name", value = "Bob", path = "/",
                    domain = "example.com", secure = true, httponly = true,
                    expires = "Wed, 09 Jun 2021 10:18:14 GMT", max_age = 50,
                    samesite = "Strict", extension = "a4334aebaec"
                })
                if not ok then
                    ngx.log(ngx.ERR, err)
                    return
                end
                local ok, err = cookie:set({
                    key = "Age", value = "20",
                })
                if not ok then
                    ngx.log(ngx.ERR, err)
                    return
                end
            ';
        }

        # REF: https://github.com/openresty/headers-more-nginx-module
        more_set_headers 'Server: my-server';
        location = /headers {
            more_set_headers 'X-MyHeader: blah' 'X-MyHeader2: foo';
            more_set_headers -t 'text/plain text/css' 'Content-Type: text/foo';
            more_set_headers -s '400 404 500 503' -s 413 'Foo: Bar';
            more_clear_headers 'Content-Type';
            return 200 "OK";
        }
        location = /type {
            more_set_headers 'Content-Type: text/plain';
            return 200 "OK";
        }
        more_set_input_headers -r 'X-Foo: howdy';

        # REF: https://github.com/openresty/lua-cjson
        location = /cjson {
            content_by_lua '
                local cjson = require "cjson"
                ngx.say("read: ", cjson.encode({0, 1}))
            ';
        }

        # REF: https://github.com/openresty/lua-resty-memcached
        location = /memcached {
            content_by_lua '
                local memcached = require "resty.memcached"
                local memc, err = memcached:new()
                if not memc then
                    ngx.say("failed to instantiate memc: ", err)
                    return
                end

                memc:set_timeout(1000) -- 1 sec

                -- or connect to a unix domain socket file listened
                -- by a memcached server:
                --     local ok, err = memc:connect("unix:/path/to/memc.sock")

                local ok, err = memc:connect("127.0.0.1", 11211)
                if not ok then
                    ngx.say("failed to connect: ", err)
                    return
                end

                local ok, err = memc:flush_all()
                if not ok then
                    ngx.say("failed to flush all: ", err)
                    return
                end

                local ok, err = memc:set("dog", 32)
                if not ok then
                    ngx.say("failed to set dog: ", err)
                    return
                end

                local res, flags, err = memc:get("dog")
                if err then
                    ngx.say("failed to get dog: ", err)
                    return
                end

                if not res then
                    ngx.say("dog not found")
                    return
                end

                ngx.say("dog: ", res)

                -- put it into the connection pool of size 100,
                -- with 10 seconds max idle timeout
                local ok, err = memc:set_keepalive(10000, 100)
                if not ok then
                    ngx.say("cannot set keepalive: ", err)
                    return
                end

                -- or just close the connection right away:
                -- local ok, err = memc:close()
                -- if not ok then
                --     ngx.say("failed to close: ", err)
                --     return
                -- end
            ';
        }

        # REF: https://github.com/openresty/lua-resty-mysql
        location = /mysql {
            content_by_lua '
                local mysql = require "resty.mysql"
                local db, err = mysql:new()
                if not db then
                    ngx.say("failed to instantiate mysql: ", err)
                    return
                end

                db:set_timeout(1000) -- 1 sec

                -- or connect to a unix domain socket file listened
                -- by a mysql server:
                --     local ok, err, errcode, sqlstate =
                --           db:connect{
                --              path = "/path/to/mysql.sock",
                --              database = "ngx_test",
                --              user = "ngx_test",
                --              password = "ngx_test" }

                local ok, err, errcode, sqlstate = db:connect{
                    host = "127.0.0.1",
                    port = 3306,
                    database = "ngx_test",
                    user = "ngx_test",
                    password = "ngx_test",
                    charset = "utf8",
                    max_packet_size = 1024 * 1024,
                }

                if not ok then
                    ngx.say("failed to connect: ", err, ": ", errcode, " ", sqlstate)
                    return
                end

                ngx.say("connected to mysql.")

                local res, err, errcode, sqlstate =
                    db:query("drop table if exists cats")
                if not res then
                    ngx.say("bad result: ", err, ": ", errcode, ": ", sqlstate, ".")
                    return
                end

                res, err, errcode, sqlstate =
                    db:query("create table cats "
                             .. "(id serial primary key, "
                             .. "name varchar(5))")
                if not res then
                    ngx.say("bad result: ", err, ": ", errcode, ": ", sqlstate, ".")
                    return
                end

                ngx.say("table cats created.")

                res, err, errcode, sqlstate =
                    db:query("insert into cats (name) "
                             .. "values (\'Bob\'),(\'\'),(null)")
                if not res then
                    ngx.say("bad result: ", err, ": ", errcode, ": ", sqlstate, ".")
                    return
                end

                ngx.say(res.affected_rows, " rows inserted into table cats ",
                        "(last insert id: ", res.insert_id, ")")

                -- run a select query, expected about 10 rows in
                -- the result set:
                res, err, errcode, sqlstate =
                    db:query("select * from cats order by id asc", 10)
                if not res then
                    ngx.say("bad result: ", err, ": ", errcode, ": ", sqlstate, ".")
                    return
                end

                local cjson = require "cjson"
                ngx.say("result: ", cjson.encode(res))

                -- put it into the connection pool of size 100,
                -- with 10 seconds max idle timeout
                local ok, err = db:set_keepalive(10000, 100)
                if not ok then
                    ngx.say("failed to set keepalive: ", err)
                    return
                end

                -- or just close the connection right away:
                -- local ok, err = db:close()
                -- if not ok then
                --     ngx.say("failed to close: ", err)
                --     return
                -- end
            ';
        }

        # REF: https://github.com/openresty/lua-resty-redis
        location = /redis {
            # need to specify the resolver to resolve the hostname
            resolver 8.8.8.8;

            content_by_lua_block {
                local redis = require "resty.redis"
                local red = redis:new()

                red:set_timeouts(1000, 1000, 1000) -- 1 sec

                -- or connect to a unix domain socket file listened
                -- by a redis server:
                --     local ok, err = red:connect("unix:/path/to/redis.sock")

                -- connect via ip address directly
                local ok, err = red:connect("127.0.0.1", 6379)

                -- or connect via hostname, need to specify resolver just like above
                local ok, err = red:connect("redis.openresty.com", 6379)

                if not ok then
                    ngx.say("failed to connect: ", err)
                    return
                end

                ok, err = red:set("dog", "an animal")
                if not ok then
                    ngx.say("failed to set dog: ", err)
                    return
                end

                ngx.say("set result: ", ok)

                local res, err = red:get("dog")
                if not res then
                    ngx.say("failed to get dog: ", err)
                    return
                end

                if res == ngx.null then
                    ngx.say("dog not found.")
                    return
                end

                ngx.say("dog: ", res)

                red:init_pipeline()
                red:set("cat", "Marry")
                red:set("horse", "Bob")
                red:get("cat")
                red:get("horse")
                local results, err = red:commit_pipeline()
                if not results then
                    ngx.say("failed to commit the pipelined requests: ", err)
                    return
                end

                for i, res in ipairs(results) do
                    if type(res) == "table" then
                        if res[1] == false then
                            ngx.say("failed to run command ", i, ": ", res[2])
                        else
                            -- process the table value
                        end
                    else
                        -- process the scalar value
                    end
                end

                -- put it into the connection pool of size 100,
                -- with 10 seconds max idle time
                local ok, err = red:set_keepalive(10000, 100)
                if not ok then
                    ngx.say("failed to set keepalive: ", err)
                    return
                end

                -- or just close the connection right away:
                -- local ok, err = red:close()
                -- if not ok then
                --     ngx.say("failed to close: ", err)
                --     return
                -- end
            }
        }

        # REF: https://github.com/openresty/set-misc-nginx-module
        location = /foo {
            set $a $arg_a;
            set_if_empty $a 56;

            # GET /foo?a=32 will yield $a == 32
            # while GET /foo and GET /foo?a= will
            # yeild $a == 56 here.
            return 200 $a;
        }

        location = /bar-mysql {
            set $foo "hello\n\n'\"\\";
            set_quote_sql_str $foo $foo; # for mysql

            # OR in-place editing:
            #   set_quote_sql_str $foo;

            # now $foo is: 'hello\n\n\'\"\\'
            return 200 $foo;
        }

        location = /bar-pgsql {
            set $foo "hello\n\n'\"\\";
            set_quote_pgsql_str $foo;  # for PostgreSQL

            # now $foo is: E'hello\n\n\'\"\\'
            return 200 $foo;
        }

        location = /json {
            set $foo "hello\n\n'\"\\";
            set_quote_json_str $foo $foo;

            # OR in-place editing:
            #   set_quote_json_str $foo;

            # now $foo is: "hello\n\n'\"\\"
            return 200 $foo;
        }

        location = /baz {
            set $foo "hello%20world";
            set_unescape_uri $foo $foo;

            # OR in-place editing:
            #   set_unescape_uri $foo;

            # now $foo is: hello world
            return 200 $foo;
        }

        location = /foo-hash {
            set_hashed_upstream $backend universe $arg_id;
            # drizzle_pass $backend; # used with ngx_drizzle
            return 200 "OK";
        }

        location = /base32 {
            set $a 'abcde';
            set_encode_base32 $a;
            set_decode_base32 $b $a;

            # now $a == 'c5h66p35' and
            # $b == 'abcde'
            return 200 $b;
        }

        location = /base64 {
            set $a 'abcde';
            set_encode_base64 $a;
            set_decode_base64 $b $a;

            # now $a == 'YWJjZGU=' and
            # $b == 'abcde'
            return 200 $b;
        }

        location = /hex {
            set $a 'abcde';
            set_encode_hex $a;
            set_decode_hex $b $a;

            # now $a == '6162636465' and
            # $b == 'abcde'
            return 200 $b;
        }

        # GET /sha1 yields the output
        #   aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
        location = /sha1 {
            set_sha1 $a hello;
            return 200 $a;
        }

        # ditto
        location = /sha1-2 {
            set $a hello;
            set_sha1 $a;
            return 200 $a;
        }

        # GET /today yields the date of today in local time using format 'yyyy-mm-dd'
        location = /today {
            set_local_today $today;
            return 200 $today;
        }

        # GET /signature yields the hmac-sha-1 signature
        # given a secret and a string to sign
        # this example yields the base64 encoded singature which is
        # "HkADYytcoQQzqbjQX33k/ZBB/DQ="
        location = /signature {
            set $secret_key 'secret-key';
            set $string_to_sign "some-string-to-sign";
            set_hmac_sha1 $signature $secret_key $string_to_sign;
            set_encode_base64 $signature $signature;
            return 200 $signature;
        }

        location = /rand {
            set $from 3;
            set $to 15;
            set_random $rand $from $to;

            # or write directly
            #   set_random $rand 3 15;

            return 200 $rand;  # will print a random integer in the range [3, 15]
        }
    }

    # TODO: Add https://github.com/openresty/lua-resty-lrucache
    # TODO: Add https://github.com/openresty/lua-resty-signal
    # TODO: Add https://github.com/openresty/lua-tablepool
}

# REF: https://github.com/openresty/stream-lua-nginx-module
stream {
    server {
        listen 1234;
        content_by_lua_block {
            ngx.say("Hello, Lua!")
        }
    }
}
